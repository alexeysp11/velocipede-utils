# Требования

## Способы коммуникации

Для работы данного сервиса можно попробовать различные способы взаимодействия:
1. TCP: проще выполнить коммуникацию, при которой соединение остается постоянным во время всей сессии; однако такой способ взаимодействия менее устойчив к разрыву сети и увеличивает нагрузку на сервер, что особенно плохо при большом количестве клиентов.
2. HTTP/WebAPI: возможно отправлять на клиент некоторую информацию о пользовательской сессии, чтобы не держать соединение постоянно открытым, и можно было восстанавливать сессию даже после разрыва сети; также следует продумать, как сохранять сессию на сервере и отключать неактивные сессии (например, сохранять в БД и отключать с помощью воркера на стороне сервера).
3. gRPC: модель взаимодействия аналогична HTTP/WebAPI.

### HTTP/WebAPI

- Клиент выполняет запрос к сервису, при этом запрос может быть пустым или содержать информацию о сессии.
- Сервис сохраняет информацию о сессиях в памяти:
    - С помощью `appsettings.json` можно настроить следующие параметры: максимальное количество активных сессий, время удержания сессии активной.
    - Для того, чтобы было легче восстановить сессию, можно сохранять её в памяти в словаре, чтобы был доступ по UID сессии (сохранять экземпляр класса `MenuFormResolver` и после нового ввода от пользователя вызывать метод `ProcessUserInput`).
    - Предусмотреть удаление неактивных сессий.
- Сервис выполняет обработку запроса следующим образом:
    - Проверка, что в теле запроса указан параметр `SessionUid`, и этот `SessionUid` находится в списке активных сессий.
        - Если проверка не пройдена, то создать сессию, сохранить её в памяти и отправить ответ клиенту.
        - Если проверка пройдена успешно, то обновить последнее время доступа к сессии и перейти дальше по конвейеру обработки запроса.
    - Проверка данных для авторизации.
    - Обработка пользовательского ввода.
- После обработки запроса, сервис формирует ответ, содержащий данные для отображения, UID сессии, данные пользователя, предыдущий пользовательский ввод.

Пример ответа от сервера:
```JSON
{
    "SessionUid": "fa603a27-e0bc-4580-ac50-dbdd41edd284",
    "FormHeight": 20,
    "FormWidth": 35,
    "MenuCode": "2/3/1",
    "DisplayedInfo": "ERROR:\nTHIS OPERATION IS CANCELLED!",
    "SavedDisplayedInfo": "    TCP SERVICE\nTEST FORM\n\nREQUEST NUMBER: 1\nREQUEST BODY:",
    "UserLogin": "45321",
    "UserInput": "-n"
}
```

## Функциональные требования

### Движок серверного приложения

Приложение должно обладать следующим фукнционалом:
- [x] С клиента идет TCP-запрос к сервису; сервис обрабатывает запрос и инициирует TCP-соединение.
- [x] Приложение может обрабатывать несколько запросов одновременно.
- [x] Соединение остается постоянным на протяжении всей сессии.
- [ ] Коммуникация в рамках сессии производится в следующем виде:
    - [x] Клиент набирает текст, нажимает Enter, и отправляет новый TCP-запрос на сервис. Сообщение не считается отправленным, пока не был нажат Enter.
    - [ ] Существует набор спецсимволов:
        - [ ] `-n`: далее.
            - Реализуется <u>на уровне валидации конкретного контрола</u>.
            - Очень часто приравнивается к нажатию на Enter с пустой строкой.
        - [ ] `-b`: назад.
            - Реализуется <u>на уровне валидации конкретного контрола</u>.
        - [x] `-q`: выйти из приложения.
            - Реализуется <u>на уровне базового контрола</u>.
            - Если пользователь действительно хочет выйти из приложения, то необходимо разорвать сессию: отправляем на клиент форму с сообщением, что сессия разорвана, и в JSON отправляем флаг о выходе из приложения; в свою очередь, на клиенте при заполнении этого флага просто завершаем консольное приложение.
        - [ ] `-m`: выйти в главное меню.
            - Реализуется <u>на уровне базового контрола</u>.
        - [ ] `-x`: отменить.
            - Реализуется <u>на уровне валидации конкретного контрола</u>.
            - В большинстве случаев эквивалентен комбинации `-b`.
            - При использовании `ComboEditControl` символ `-x` означает выход из контрола и переход назад, а символ `-b` - пролистнуть назад список вариантов для выбора.
        - [ ] `-h`: помощь/информация.
            - Реализуется <u>на уровне валидации конкретного контрола</u>.
        - [ ] `-c`: настройки.
            - Реализуется <u>на уровне базового контрола</u>.
    - [x] В процессе обработки запроса сервис формирует и отправляет некую текстовую информацию в виде двумерного массива символов заданного размера (например, 26 в ширину и 16-18 в высоту).
    - [x] Затем цикл повторяется: клиент набирает сообщение, нажимает Enter, а потом сервис его обрабатывает.
- [ ] Контролы делятся на следующие типы: текстовое поле отображения `TextControl`, текстовое поле ввода `TextEditControl`. Допускается наследоваться от указанных полей и создавать контролы для специализированных нужд (например, ввод пароля, ввод товара с кастомной валидацией). Также допускается определять методы для валидации как делегаты (делегаты будут вызываться в теле метода, выполняющего валидацию; имя метода валидации в контроле начинается с `On`).
    - [x] Текстовое поле отображения `TextControl`:
        - **Наследование**: является базовым.
        - **Поля**: наименование `Name`, координаты `X` и `Y`, ширина `Width`, значение `Value`, видимый `Visible`, выравнивание по горизонтали `HorizontalAlignment`, инвертирование `Inverted`.
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое).
        - Может отображаться на несколько строк.
    - [x] Текстовое поле ввода `TextEditControl`:
        - **Наследование**: наследуется от `TextControl`.
        - **Поля**: обязательно для заполнения `Required`, `Hint` (подсказка для ввода внизу формы).
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое, также отображает подсказку); валидация перед отображением `RequireValidation` (допускает ввод значений в поле, если оно обязательно для заполнения); валидация ввода `EnterValidation`.
    - [ ] Поле выбора из списка `ComboEditControl`:
        - **Наследование**: наследуется от `TextEditControl`.
        - **Валидация**: при установке фокуса на контроле, открывается форма со списком и полем ввода. Список делится на страницы, можно переходить между страницами с помощью `-n`/`-b`. Выход из контрола производится либо при выборе элемента из существующего списка, либо при нажатии `-x` (в таком случае фокус будет на контроле, который был до комбобокса).
        - **Поля**: множественный выбор `MultiSelect`; необходимо открытие отдельной формы выбора `OnlyFormInput` (если нет, то ввод вариантов может выполняться как в обычном `TextEditControl`, а форма выбора открывается только при вводе `-n`/Enter; если да, то ввод значений возможен только в форме выбора); показывать дополнительную информацию об элементах `AdditionalItemsInfo` (можно воспользоваться с помощью комбинации `-h 1`/`-h 2`/`-h 12`).
- [x] На форме в методе `InitializeComponent` определяются и регистрируются все контролы, а также свойства этих контролов.
- [x] Есть базовая форма `BaseForm`, которая отображает и обрабатывает контролы: отображение производится сверху вниз и слева направо.
- [ ] Есть класс `MenuFormResolver` для работы с пунктами меню, который выполняет следующие операции:
    - [x] Принимает на вход код операции (например, `/0/0/1`, `/0/0/2`, `/1/0/3`, etc).
    - [x] По коду операции создает экземпляр формы.
    - [ ] Заполняет атрибуты формы.
    - [x] Вызывает методы `Init()` и `Show()` у формы.
    - [x] Сохраняет данные пользовательской сессии (ИД сессии, пункт меню, отображаемая информация на экране у клиента).
    - [ ] Удаление неактивных сессий.
- [ ] Авторизация и обработка пользовательских сессий:
    - [ ] Отображение введенного пароля на форме с помощью символа `*`.
    - [ ] При вводе пароля все символы должны отображаться с помощью символа `*`.
    - [ ] У каждой сессии есть статус: "auth session", "long term session". В зависимости от этого статуса определяется, как эта сессия будет удаляться:
        - [ ] Сессия в статусе "auth session" удаляется в течение 2-5 минут.
        - [ ] Сессия в статусе "long term session" удаляется в течение 20-60 минут.
        - [ ] Если пользователь успешно авторизовался, то сессия переводится в статус "long term session" (в случае, если нет других активных сессий у данного пользователя). Если уже есть одна и более сессий в статусе "long term session", то пользователь должен выбрать, какую из них подключать.
    - [ ] В самом начале при авторизации можно выбрать БД, к которой подключаться. На основе указанного подключения к БД, можно проверить корректность введенных логина и пароля. Подключение к in-memory БД возможно только в целях отладки, и ограничивается логином и паролем, установленными на уровне конфигов.

### Клиентское приложение

- [ ] Клиентское приложение может подключаться к различным протоколам:
    - [x] TCP
    - [x] HTTP
    - [ ] gRPC
- [ ] Для коммуникации с сервисом лучше написать кастомный клиент, запускаемый из командной строки. Таким образом, будут следующие компоненты:
    - [ ] Библиотека сетевого взаимодействия `ClientAdapter`: коммуницирует с сервисом по TCP и возвращает двумерный массив символов.
    - [ ] Консольное приложение: имеет область, в которой отображает информацию; каждый раз после получения ответа от сервиса очищает область отображения.
- [ ] Пункты меню:
    - [ ] `1`: Тестирование.
    - [ ] `2`: Пользователи:
        - [ ] `2/1`: поиск
        - [ ] `2/2`: права доступа пользователей к ресурсам
        - [ ] `2/3`: редактирование пользователя.
    - [ ] `3`: Приложения:
        - [ ] `3/1`: поиск
        - [ ] `3/2`: права доступа приложений/модулей к ресурсам
        - [ ] `3/3`: пункты меню (создание, редактирование, включение/отключение).
        - [ ] `3/4`: развертывание приложений (запустить/настроить сервисы для тестовой среды
        - [ ] `3/5`: локальная копия БД
        - [ ] `3/6`: релиз: выполнить, откатить.
        - [ ] `3/7`: сервисы: связи между сервисами, права доступа сервиса к ресурсам.
    - [ ] `4`: Конфигурационные переменные (найти, просмотреть, редактировать, условия выполнения, указать приложения):
        - [ ] `4/1`: общие переменные
        - [ ] `4/2`: переменные по приложению.
    - [ ] `5`: Задачи:
        - [ ] `5/1`: поиск/редактировать
        - [ ] `5/2`: назначить
        - [ ] `5/3`: отменить.
- [ ] Навигация для выбора пунктов меню немного похожа на работу с файловой системой на Linux. Допускается выбирать пункты меню следующим образом:
    - [ ] Одиночный пункт меню: например, `1`.
    - [ ] Полный путь: например, `/2/3/1`.
    - [ ] Относительный путь, когда пользователь уже находится в некотором пункте меню: например, `./3/1` или `./0`.
