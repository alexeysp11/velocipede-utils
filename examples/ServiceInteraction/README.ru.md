# ServiceInteraction

[English](README.md) | [Русский](README.ru.md)

Представим, что есть несколько компонентов, которые "общаются" между собой, как представлено на рисунке ниже.

![ServiceInteraction](../../docs/img/examples/ServiceInteraction.png)

Ксательно реализации компонентов и коммуникации между ними есть несколько пунктов:
- эти компоненты реализованы в виде классов в библиотеке C#;
- компоненты коммуницируют не напрямую, а через "ресолвер": 
    - "ресолвер" обращается к БД для того, чтобы получить информацию о типе взаимодействия.

Имеется несколько видов оболочек:
- монолит;
- HTTP;
- gRPC.

![ExplicitImplicitCall](../../docs/img/examples/ExplicitImplicitCall.png)

Алгоритмы для выбора эндпоинта в распределённой системе:
- **Случайный выбор**: Простой и эффективный способ, но может привести к неэффективному использованию ресурсов, особенно если один из инстансов перегружен.
- **Round-robin**: Равномерное распределение запросов между инстансами, что помогает балансировать нагрузку. Однако, не учитывает текущую загрузку инстансов.
- **Выбор наименее загруженного сервиса**: Этот способ позволяет выбирать инстанс с наименьшей нагрузкой, что может повысить производительность и эффективность использования ресурсов (т.е. оценивает общую нагрузку на сервер, включая процессорное время, загрузка процессора, использование памяти, количество активных запросов, скорость сети, количество обработанных запросов в единицу времени и другие параметры).
- **Least Connections**: Выбор сервиса с наименьшим количеством активных соединений.
- **Weighted Round-robin**: Распределение запросов с учетом весов инстансов (например, более мощные серверы получают больший вес).
- **Least Response Time**: Выбор сервиса с наименьшим временем ответа.

## EndpointPool

Существует коллекция, в которой хранятся объекты типа `EndpointCollectionParameter` (т.е. информация об активных эндпоинтах). Но бывает такое, что эндпоинт временно становится недоступен, соответственно, такой эндпоинт нужно будет удалить из коллекции. Однако этот объект так и останется в куче до тех пор, пока его не удалит сборщик мусора. Проблема в том, что когда восстановится соединение с эндпоинтом, понадобится создавать точно такой же эндпоинт в памяти (таким образом, эндпоинтов в управляемой куче будет два, что является не очень правильным с точки зрения использования памяти).

Для решения данной проблемы предполагается использование класса `EndpointPool`, который будет управлять аллокацией/деаллокацией эндпоинтов в памяти, реализуя [паттерн объектного пула](https://en.wikipedia.org/wiki/Object_pool_pattern).
